<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.525">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Data Mining Techniques - Outliers</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Data Mining Techniques</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./terminology.html"> 
<span class="menu-text">Terminology</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./web_scraping.html"> 
<span class="menu-text">Web Scraping</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./data_visualization.html"> 
<span class="menu-text">Data Visualization</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./frequent_patterns.html"> 
<span class="menu-text">Frequent Patterns</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./classification_regression.html"> 
<span class="menu-text">Classification and Regression</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./cluster_analysis.html"> 
<span class="menu-text">Cluster Analysis</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./pca.html"> 
<span class="menu-text">Principal Component Analysis (PCA)</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./outliers.html" aria-current="page"> 
<span class="menu-text">Outliers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./neural_networks.html"> 
<span class="menu-text">Neural Networks</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-bi-github" role="button" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-bi-github">    
        <li>
    <a class="dropdown-item" href="https://github.com/clickityKlein/Data-Mining">
 <span class="dropdown-text">Source Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://github.com/clickityKlein">
 <span class="dropdown-text">Carl Kleinâ€™s Main Page</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#basic-concepts" id="toc-basic-concepts" class="nav-link active" data-scroll-target="#basic-concepts">Basic Concepts</a>
  <ul class="collapse">
  <li><a href="#detecting-global-outliers" id="toc-detecting-global-outliers" class="nav-link" data-scroll-target="#detecting-global-outliers">Detecting Global Outliers</a></li>
  <li><a href="#contextual-vs.-behavioral-attributes" id="toc-contextual-vs.-behavioral-attributes" class="nav-link" data-scroll-target="#contextual-vs.-behavioral-attributes">Contextual vs.&nbsp;Behavioral Attributes</a></li>
  <li><a href="#contextual-global-and-local-outliers" id="toc-contextual-global-and-local-outliers" class="nav-link" data-scroll-target="#contextual-global-and-local-outliers">Contextual, Global, and Local Outliers</a></li>
  <li><a href="#comparison-between-multiple-types-of-outliers" id="toc-comparison-between-multiple-types-of-outliers" class="nav-link" data-scroll-target="#comparison-between-multiple-types-of-outliers">Comparison Between Multiple Types of Outliers</a></li>
  <li><a href="#challenges-of-outlier-detection" id="toc-challenges-of-outlier-detection" class="nav-link" data-scroll-target="#challenges-of-outlier-detection">Challenges of Outlier Detection</a></li>
  </ul></li>
  <li><a href="#detection-methods" id="toc-detection-methods" class="nav-link" data-scroll-target="#detection-methods">Detection Methods</a>
  <ul class="collapse">
  <li><a href="#supervised-semi-supervised-and-unsupervised-methods" id="toc-supervised-semi-supervised-and-unsupervised-methods" class="nav-link" data-scroll-target="#supervised-semi-supervised-and-unsupervised-methods">Supervised, Semi-Supervised, and Unsupervised Methods</a></li>
  <li><a href="#statistical-methods-proximity-based-methods-and-reconstruction-based-methods" id="toc-statistical-methods-proximity-based-methods-and-reconstruction-based-methods" class="nav-link" data-scroll-target="#statistical-methods-proximity-based-methods-and-reconstruction-based-methods">Statistical Methods, Proximity-based Methods, and Reconstruction-based Methods</a></li>
  <li><a href="#detection-of-univariate-outliers-based-on-normal-distribution" id="toc-detection-of-univariate-outliers-based-on-normal-distribution" class="nav-link" data-scroll-target="#detection-of-univariate-outliers-based-on-normal-distribution">Detection of Univariate Outliers Based on Normal Distribution</a></li>
  </ul></li>
  <li><a href="#parametric-detection---interquartile-range-iqr---boxplot-5-number-summary" id="toc-parametric-detection---interquartile-range-iqr---boxplot-5-number-summary" class="nav-link" data-scroll-target="#parametric-detection---interquartile-range-iqr---boxplot-5-number-summary">Parametric Detection - Interquartile Range (IQR) - Boxplot (5-number Summary)</a></li>
  <li><a href="#nonparametric-detection---histogram" id="toc-nonparametric-detection---histogram" class="nav-link" data-scroll-target="#nonparametric-detection---histogram">Nonparametric Detection - Histogram</a></li>
  <li><a href="#pros-and-cons-of-statistical-methods" id="toc-pros-and-cons-of-statistical-methods" class="nav-link" data-scroll-target="#pros-and-cons-of-statistical-methods">Pros and Cons of Statistical Methods</a></li>
  <li><a href="#implementation-python-coding" id="toc-implementation-python-coding" class="nav-link" data-scroll-target="#implementation-python-coding">Implementation (Python Coding)</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Outliers</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>An outlier is a data object that deviates significantly from the rest of the objects, suspected of being generated by a different mechanism.</p>
<section id="basic-concepts" class="level1">
<h1>Basic Concepts</h1>
<p><strong>Outlier Detection and Novelty Detection</strong></p>
<ul>
<li>monitoring a social media web site where new content is incoming, novelty detection may identify new topics and trends in a timely manner, novel topics may initially appear as outliers</li>
<li>outlier detection and novelty detection share some similarity in modeling and detection methods</li>
<li>main difference: in novelty detection, once new topics are confirmed, they are usually incorporated into the model of normal behavior so that follow-up instances are not treated as outliers anymore</li>
</ul>
<section id="detecting-global-outliers" class="level2">
<h2 class="anchored" data-anchor-id="detecting-global-outliers">Detecting Global Outliers</h2>
<ul>
<li>find an appropriate measurement of deviation with respect to the application in question</li>
<li>important in many applications
<ul>
<li>intrusion detection in computer networks</li>
<li>trading transaction auditing systems</li>
</ul></li>
</ul>
</section>
<section id="contextual-vs.-behavioral-attributes" class="level2">
<h2 class="anchored" data-anchor-id="contextual-vs.-behavioral-attributes">Contextual vs.&nbsp;Behavioral Attributes</h2>
<ul>
<li>in contextual outlier detection, the attributes of the data objects in question are divided into two groups
<ul>
<li>contextual attributes</li>
<li>behavioral attribues</li>
</ul></li>
<li>the contextual attributes of a data object define the objectâ€™s context
<ul>
<li>example: temperature contextual attributes may be date and location</li>
</ul></li>
<li>the behavioral attributes define the objectâ€™s characteristics, and are used to evaluate whether the object is an outlier in the context to which it belongs
<ul>
<li>example: temperature behavioral attributes may be temperature, humidity, and pressure</li>
</ul></li>
<li>Whether a data object is a contextual outlier depends on not only the behavioral attributes but also the contextual attributes</li>
</ul>
</section>
<section id="contextual-global-and-local-outliers" class="level2">
<h2 class="anchored" data-anchor-id="contextual-global-and-local-outliers">Contextual, Global, and Local Outliers</h2>
<ul>
<li>global outlier detection can be regarded as a special case of contextual outlier detection, where the set of contextual attributes is empty - <em>global outlier detection uses the whole dataset as the context</em>.</li>
<li>contextual outlier analysis provideds flexibility to users in that one can examine outliers in different contexts, which can be highly desirable in many applications</li>
<li>the quality of contextual outlier detection in an application depends on the meaningfulness of the contextual attributes, in addition to the measurement of the deviation of an object to the majority in the space of behavior attributes</li>
<li>applications of collective outliers:
<ul>
<li>intrusion detection, if several computers are sending denial-of-service packages to each other, this could indicate an attack</li>
<li>a large set of transactions of the same stock between a small number of parties in a short period could indicate market manipulation</li>
</ul></li>
</ul>
</section>
<section id="comparison-between-multiple-types-of-outliers" class="level2">
<h2 class="anchored" data-anchor-id="comparison-between-multiple-types-of-outliers">Comparison Between Multiple Types of Outliers</h2>
<ul>
<li>a dataset can have many types of outliers</li>
<li>an object may belong to multiple types of outliers</li>
<li>different applications or purposes could require detection of different types of outliers</li>
<li>global outlier detection is the simplest</li>
<li>context outlier detection requires background information</li>
<li>collective outlier detection requires background information to model the relationship among objects to find groups of outliers</li>
</ul>
</section>
<section id="challenges-of-outlier-detection" class="level2">
<h2 class="anchored" data-anchor-id="challenges-of-outlier-detection">Challenges of Outlier Detection</h2>
<ul>
<li>modeling normal objects and outliers effectively
<ul>
<li>the border between data normality and abnormality (outliers) is often not clear-cut</li>
</ul></li>
<li>application-specific outlier detection
<ul>
<li>the relationship among objects highly depends on applications</li>
</ul></li>
<li>handling noise in outlier detection
<ul>
<li>noise often unavoidably exists in data collected in many applications</li>
<li>low data quality and the presence of noise bring a huge challenge to outlier detection</li>
</ul></li>
<li>interpretability
<ul>
<li>detection and <strong>understanding</strong> of outliers</li>
</ul></li>
</ul>
</section>
</section>
<section id="detection-methods" class="level1">
<h1>Detection Methods</h1>
<ul>
<li>supervised methods</li>
<li>semi-supervised methods</li>
<li>unsupervised methods</li>
<li>statistical methods</li>
<li>proximity-based methods</li>
<li>reconstruction-based methods</li>
</ul>
<section id="supervised-semi-supervised-and-unsupervised-methods" class="level2">
<h2 class="anchored" data-anchor-id="supervised-semi-supervised-and-unsupervised-methods">Supervised, Semi-Supervised, and Unsupervised Methods</h2>
<ul>
<li>supervised methods model data normality and abnormality
<ul>
<li>imbalanced datasets</li>
<li>avoid many false positives in outlier detection</li>
</ul></li>
<li>unsupervised methods make an implicit assumption
<ul>
<li>normal objects are somewhat <em>clustered</em></li>
</ul></li>
<li>semi-supervised methods
<ul>
<li>although obtaining some labeled examples is feasible, the number of such labeled examples is often small</li>
</ul></li>
</ul>
</section>
<section id="statistical-methods-proximity-based-methods-and-reconstruction-based-methods" class="level2">
<h2 class="anchored" data-anchor-id="statistical-methods-proximity-based-methods-and-reconstruction-based-methods">Statistical Methods, Proximity-based Methods, and Reconstruction-based Methods</h2>
<ul>
<li>Statistical methods (also known as model-based methods) make assumptions of data normality
<ul>
<li>Example: detecting outliers using a statistical (Gaussian) model</li>
</ul></li>
<li>Proximity-based methods assume that an object is an outlier if the nearest neighbors of the object are far away in feature space, that is, the proximity of the object to its neighbors significantly deviates from the proximity of most of the other objects to their neighbors in the same data set</li>
<li>Reconstruction-based methods: matrix-factorization based methods and pattern-based compression methods
<ul>
<li>normal data samples often share certain similarities, can often be represented in a more succinct way, compared with their original representation</li>
<li>with the succinct representation, we can reconstruct the original representation of the normal samples well</li>
<li>for the samples that cannot be reconstructed well by the succinct representation, we flag them as outliers</li>
</ul></li>
</ul>
<p>The overall idea behind statistical methods for outlier detection is to learn a generative model fitting the given dataset, and then identify those objects in low-probability regions of the model as outliers.</p>
<p>A parametric method assumes that the normal data objects are generated by a parametric distribution with a finite number of parameters <span class="math inline">\(\Theta\)</span>.</p>
<ul>
<li>the probability density function of the parametric distribution <span class="math inline">\(f(x, \Theta)\)</span> gives the probability that object <span class="math inline">\(x\)</span> is generated by the distribution</li>
<li>the smaller this value, the more likely <span class="math inline">\(x\)</span> is an outlier</li>
</ul>
<p>A nonparametric method tries to determine the model from the input data.</p>
</section>
<section id="detection-of-univariate-outliers-based-on-normal-distribution" class="level2">
<h2 class="anchored" data-anchor-id="detection-of-univariate-outliers-based-on-normal-distribution">Detection of Univariate Outliers Based on Normal Distribution</h2>
<ul>
<li>assumption: data are generated from a normal distribution</li>
<li>learn the parameters of the normal (Gaussian) distribution from the input data, and identify the points with low probability as outliers</li>
<li><strong>example</strong>: suppose we have a cityâ€™s average temperature values for a single month in the last 10 years:
<ul>
<li>24.0, 28.9, 28.9, 29.0, 29.1, 29.1, 29.2, 29.2, 29.3, and 29.4</li>
</ul></li>
<li>a normal distribution is determined by two parameters
<ul>
<li>the mean <span class="math inline">\(\mu\)</span></li>
<li>the standard deviation <span class="math inline">\(\sigma\)</span></li>
</ul></li>
<li>use the maximum likelihood method to estimate the parameters <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span>:</li>
</ul>
<p><img src="images/outlier_normal_dist.png" class="img-fluid"></p>
</section>
</section>
<section id="parametric-detection---interquartile-range-iqr---boxplot-5-number-summary" class="level1">
<h1>Parametric Detection - Interquartile Range (IQR) - Boxplot (5-number Summary)</h1>
<p>Using the IQR, we can treat the following as outliers:</p>
<ul>
<li>Given the five-number summary:
<ul>
<li>min</li>
<li>lower quartile (Q1)</li>
<li>median (Q2)</li>
<li>upper quartile (Q3)</li>
<li>max</li>
</ul></li>
<li><span class="math inline">\(IQR = Q3 - Q1\)</span></li>
<li>Outliers:
<ul>
<li><span class="math inline">\(Outlier_{max} &gt; 1.5*IQR\)</span> or <span class="math inline">\(Outlier_{max} &gt; Q3\)</span></li>
<li><span class="math inline">\(Outlier_{min} &lt; 1.5*IQR\)</span> or <span class="math inline">\(Outlier_{min} &lt; Q1\)</span></li>
<li>concept: <span class="math inline">\([Q1 - 1.5*IQR, Q3 + 1.5*IQR]\)</span> contains 99.3% of the objects</li>
</ul></li>
</ul>
<p><img src="images/iqr_outliers.png" class="img-fluid"></p>
</section>
<section id="nonparametric-detection---histogram" class="level1">
<h1>Nonparametric Detection - Histogram</h1>
<ul>
<li>construct a histogram using the input data (training data)</li>
<li>if the object falls in one of the histogramâ€™s bins, the object is regarded as normal, otherwise it is considered an outlier</li>
<li>use the histogram to assign an outlier score to an object, such as the reciprocal of the volume of the bin in which the object falls</li>
<li><strong>drawbacks</strong>: hard to choose an appropriate bin size</li>
</ul>
</section>
<section id="pros-and-cons-of-statistical-methods" class="level1">
<h1>Pros and Cons of Statistical Methods</h1>
<ul>
<li>Advantage: outlier detection may be statistically justifiable</li>
<li>Challenge: statistical methods for outlier detection on high-dimensional data</li>
<li>The computational cost of statistical methods depends on the models</li>
</ul>
</section>
<section id="implementation-python-coding" class="level1">
<h1>Implementation (Python Coding)</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="https://clickityklein.github.io/Carl-Klein/">About Carl Klein</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>